// src/ui.js
// @version 1.5.23 - Added event.target/currentTarget logging to Play/Stop handlers.
// @previous 1.5.22 - DIAGNOSTIC: Commented out Stop button listener attachment. (Reverted that comment)
// @previous 1.5.21 - Delay enabling Stop button in _handleModeChange using setTimeout.


import * as logger from './utils/logger.js';
import {
    CreateEntityCommand,
    DeleteEntityCommand,
    UpdateComponentCommand,
    SaveSceneCommand,
    LoadSceneCommand
} from './editor/command-manager.js';
import { UIComponent } from './ui/ui-component.js';
import { engineConfig } from './engine-config.js';
import { HierarchyPanel } from './ui/hierarchy-panel.js';


// ==================================
// UIManager Class (Unchanged)
// ==================================
export class UIManager {
    /* ... (Implementation unchanged) ... */
    constructor(editor) { if (!editor) throw new Error("UIManager requires an editor instance."); this.editor = editor; this.container = null; this.components = []; }
    initialize(container) { if (!container) throw new Error("UIManager requires a container element."); this.container = container; this.components = []; logger.log('UI Manager: Initializing components...'); const componentClasses = [ Toolbar, HierarchyPanel, Inspector, MaterialEditor, StatusBar ]; componentClasses.forEach(ComponentClass => { try { const componentInstance = new ComponentClass(this.editor); componentInstance.initialize(this.container); this.components.push(componentInstance); } catch (error) { logger.error(`UI Manager: Failed to initialize ${ComponentClass.name}:`, error); } }); logger.log('UI Manager finished initialization.'); return this; }
    destroy() { logger.log('UI Manager: Destroying components...'); for (let i = this.components.length - 1; i >= 0; i--) { try { this.components[i]?.destroy(); } catch (error) { logger.error(`UI Manager: Error destroying ${this.components[i]?.constructor?.name}:`, error); } } this.components = []; this.container = null; logger.log('UI Manager: All components destroyed.'); }
}

// ==================================
// Toolbar Class (MODIFIED Event Handlers)
// ==================================
class Toolbar extends UIComponent {
    constructor(editor) { /* ... (unchanged) ... */ super(editor); this.buttons = {}; this.fileInput = null; this._updateButtonsState = this._updateButtonsState.bind(this); this._handleSave = this._handleSave.bind(this); this._handleLoadClick = this._handleLoadClick.bind(this); this._handleFileInputChange = this._handleFileInputChange.bind(this); this._handlePlay = this._handlePlay.bind(this); this._handleStop = this._handleStop.bind(this); this._handleModeChange = this._handleModeChange.bind(this); this._handleAddModel = this._handleAddModel.bind(this); this._handleStartCreateCube = this._handleStartCreateCube.bind(this); this._handleUndo = this._handleUndo.bind(this); this._handleRedo = this._handleRedo.bind(this); this._handleDeleteSelected = this._handleDeleteSelected.bind(this); this._handleAddCubeOld = this._handleAddCubeOld.bind(this); this._handleAddSphereOld = this._handleAddSphereOld.bind(this); }

    _createElement() {
        const toolbarDiv = document.createElement('div');
        toolbarDiv.className = 'editor-toolbar editor-ui-panel';

        // Create buttons
        this.buttons.play = this._makeButton('▶ Play', null, 'play-button', '#4CAF50', '#388E3C');
        this.buttons.stop = this._makeButton('■ Stop', null, 'stop-button', '#f44336', '#d32f2f');
        // ... (other button creations unchanged) ...
        this.buttons.undo = this._makeButton('Undo', null, 'undo-button');
        this.buttons.redo = this._makeButton('Redo', null, 'redo-button');
        this.buttons.addCubeOld = this._makeButton('Add Cube (Old)', null, 'add-cube-old-button');
        this.buttons.addSphereOld = this._makeButton('Add Sphere (Old)', null, 'add-sphere-old-button');
        this.buttons.startCreateCube = this._makeButton('Create Cube', null, 'create-cube-button');
        this.buttons.addModel = this._makeButton('Add Model', null);
        this.buttons.delete = this._makeButton('Delete Sel.', null);
        this.buttons.save = this._makeButton('Save Scene', null);
        this.buttons.load = this._makeButton('Load Scene', null);

        this.fileInput = document.createElement('input'); /* ... */ this.fileInput.type = 'file'; this.fileInput.accept = '.json,application/json'; this.fileInput.style.display = 'none'; this.fileInput.id = 'scene-file-input';
        const separator = () => { const hr = document.createElement('div'); hr.style.cssText = 'height: 1px; background-color: #555; margin: 5px 0; width: 90%; align-self: center;'; return hr; };

        toolbarDiv.append( /* ... buttons ... */ this.buttons.play, this.buttons.stop, separator(), this.buttons.undo, this.buttons.redo, separator(), this.buttons.startCreateCube, separator(), this.buttons.addCubeOld, this.buttons.addSphereOld, this.buttons.addModel, this.buttons.delete, separator(), this.buttons.save, this.buttons.load, this.fileInput );

        // Attach listeners using addEventListener
        this.buttons.play.addEventListener('click', this._handlePlay);
        // --- Re-enabled Stop button listener ---
        this.buttons.stop.addEventListener('click', this._handleStop);
        // ---
        this.buttons.undo.addEventListener('click', this._handleUndo);
        this.buttons.redo.addEventListener('click', this._handleRedo);
        this.buttons.addCubeOld.addEventListener('click', this._handleAddCubeOld);
        this.buttons.addSphereOld.addEventListener('click', this._handleAddSphereOld);
        this.buttons.startCreateCube.addEventListener('click', this._handleStartCreateCube);
        this.buttons.addModel.addEventListener('click', this._handleAddModel);
        this.buttons.delete.addEventListener('click', this._handleDeleteSelected);
        this.buttons.save.addEventListener('click', this._handleSave);
        this.buttons.load.addEventListener('click', this._handleLoadClick);

        return toolbarDiv;
    }

    _makeButton(label, onClick, id = '', bgColor, borderColor) { /* ... (Unchanged) ... */ const btn = document.createElement('button'); btn.textContent = label; if (id) btn.id = id; btn.style.marginBottom = '4px'; btn.style.width = '95%'; if (bgColor) btn.style.backgroundColor = bgColor; if (borderColor) btn.style.borderColor = borderColor; if (bgColor || borderColor) btn.style.fontWeight = 'bold'; return btn; }
    _handleUndo(event) { event.stopPropagation(); this.editor.commandManager.undo(); }
    _handleRedo(event) { event.stopPropagation(); this.editor.commandManager.redo(); }
    _handleDeleteSelected(event) { event.stopPropagation(); this._deleteSelectedEntity(); }
    _handleAddCubeOld(event) { event.stopPropagation(); this._createEntity('Cube', { renderable: { color: 0x88dd88 }, physics: { bodyType: 'dynamic', colliderType: 'cuboid', colliderSize: [0.5, 0.5, 0.5] } }); }
    _handleAddSphereOld(event) { event.stopPropagation(); this._createEntity('Sphere', { renderable: { color: 0x8888dd }, physics: { bodyType: 'dynamic', colliderType: 'ball', colliderSize: [0.5] } }); }
    _createEntity(type, componentData = {}) { /* ... (Unchanged) ... */ if (!this.editor?.commandManager) return; logger.log(`[Toolbar DEBUG _createEntity] Received componentData:`, JSON.parse(JSON.stringify(componentData))); const offsetX = (Math.random() - 0.5) * 0.5; const offsetZ = (Math.random() - 0.5) * 0.5; const defaultPosition = [offsetX, 0.5, offsetZ]; logger.log(`[Toolbar DEBUG _createEntity] Calculated defaultPosition:`, defaultPosition); const options = { ...componentData }; logger.log(`[Toolbar DEBUG _createEntity] options.transform BEFORE merge:`, options.transform ? JSON.parse(JSON.stringify(options.transform)) : undefined); options.transform = { ...(options.transform || {}), position: options.transform?.position ?? defaultPosition, rotation: options.transform?.rotation ?? [...engineConfig.transform.rotation], scale: options.transform?.scale ?? [...engineConfig.transform.scale], }; logger.log(`[Toolbar DEBUG _createEntity] Final options.transform.position:`, options.transform.position ? JSON.parse(JSON.stringify(options.transform.position)) : undefined); logger.log(`[Toolbar DEBUG _createEntity] Creating entity command: Type=${type}, Final Options=`, JSON.parse(JSON.stringify(options))); const cmd = new CreateEntityCommand(this.editor, type, options); this.editor.commandManager.execute(cmd); }
    _handleAddModel(event) { /* ... (Unchanged) ... */ event?.stopPropagation(); if (!this.editor?.commandManager || !this.editor?.assetManager) return; const relativeAssetPath = prompt("Enter model path relative to /src/asset/\n(e.g., Airplane.glb or characters/player.glb):", "Airplane.glb"); if (relativeAssetPath && relativeAssetPath.trim() !== "") { const cleanedRelativePath = relativeAssetPath.trim().replace(/^\/+|\/+$/g, ''); if (!cleanedRelativePath) { alert("Model asset path cannot be empty."); return; } const options = { renderable: { type: 'Model', assetPath: cleanedRelativePath } }; const cmd = new CreateEntityCommand(this.editor, 'ModelEntity', options); this.editor.commandManager.execute(cmd); logger.log(`Toolbar: Adding entity with relative model path: ${cleanedRelativePath}`); } else if (relativeAssetPath !== null) { alert("Model asset path cannot be empty."); } }
    _deleteSelectedEntity() { /* ... (Unchanged) ... */ if (!this.editor?.commandManager) return; const id = this.editor.getSelectedEntity(); if (id !== null) { logger.log(`[Toolbar] Deleting selected entity: ${id}`); const cmd = new DeleteEntityCommand(this.editor, id); this.editor.commandManager.execute(cmd); } else { logger.log("[Toolbar] Delete clicked but no entity selected."); } }
    _setupEventListeners() { /* ... (Unchanged) ... */ if (!this.editor?.eventEmitter || !this.editor?.commandManager) { logger.error("Toolbar: Cannot setup listeners."); return; } const emitter = this.editor.eventEmitter; const cmdManager = this.editor.commandManager; emitter.on('entitySelected', this._updateButtonsState); cmdManager.on('change', this._updateButtonsState); emitter.on('gameModeEntered', this._handleModeChange); emitter.on('editorModeEntered', this._handleModeChange); if (this.fileInput) { this.fileInput.addEventListener('change', this._handleFileInputChange); } this._updateButtonsState(); this._handleModeChange(); }
    _updateButtonsState() { /* ... (Unchanged) ... */ if (!this.editor || !this.editor.commandManager || !this.buttons.undo) return; const cm = this.editor.commandManager; const selId = this.editor.getSelectedEntity(); const isEditorMode = this.editor.getMode() === 'editor'; this.buttons.undo.disabled = !isEditorMode || !cm.canUndo(); this.buttons.redo.disabled = !isEditorMode || !cm.canRedo(); this.buttons.delete.disabled = !isEditorMode || (selId === null); this.buttons.save.disabled = !isEditorMode; this.buttons.load.disabled = !isEditorMode; this.buttons.addCubeOld.disabled = !isEditorMode; this.buttons.addSphereOld.disabled = !isEditorMode; this.buttons.startCreateCube.disabled = !isEditorMode; this.buttons.addModel.disabled = !isEditorMode; }
    _handleModeChange() { /* ... (Unchanged - includes setTimeout) ... */ if (!this.editor || !this.buttons.play || !this.buttons.stop) return; const isGameMode = this.editor.getMode() === 'game'; this.buttons.play.disabled = isGameMode; setTimeout(() => { if (this.buttons.stop) { this.buttons.stop.disabled = !isGameMode; } }, 0); this._updateButtonsState(); }

    // --- MODIFIED: Added event target/currentTarget logging ---
    _handlePlay(event) {
        logger.log(`>>> Toolbar: _handlePlay called! Target:`, event.target, `CurrentTarget:`, event.currentTarget); // DEBUG LOG
        event.stopPropagation();
        this.editor?.enterGameMode();
    }

    _handleStop(event) {
        logger.log(`>>> Toolbar: _handleStop called! Target:`, event.target, `CurrentTarget:`, event.currentTarget); // DEBUG LOG
        event.stopPropagation();
        if (this.editor?.getMode() !== 'game') {
            logger.log(">>> Toolbar: _handleStop ignored (not in game mode).");
            return;
        }
        this.editor.enterEditorMode();
    }
    // --- END MODIFICATION ---

    _handleSave(event) { /* ... (Unchanged) ... */ event?.stopPropagation(); if (!this.editor?.commandManager) return; const defaultFilename = `scene_${new Date().toISOString().slice(0, 10)}.json`; const cmd = new SaveSceneCommand(this.editor, defaultFilename); try { cmd.execute(); } catch (e) { logger.error("Toolbar: Error executing SaveSceneCommand:", e); alert(`Error saving scene: ${e.message || 'See console'}`); } }
    _handleLoadClick(event) { /* ... (Unchanged) ... */ event?.stopPropagation(); if (this.fileInput) { this.fileInput.value = ''; this.fileInput.click(); } else { logger.error("Toolbar: File input element not found."); alert("Error: Cannot load file - input missing."); } }
    _handleFileInputChange(event) { /* ... (Unchanged) ... */ if (!this.editor?.commandManager) return; const input = event.target; if (!input.files || input.files.length === 0) return; const file = input.files[0]; const reader = new FileReader(); reader.onload = (e) => { const content = e.target?.result; if (typeof content === 'string') { if (!confirm(`Load scene from "${file.name}"?\nThis will clear the current scene and undo history.`)) { return; } try { const cmd = new LoadSceneCommand(this.editor, content, file.name); this.editor.commandManager.execute(cmd); } catch (error) { logger.error(`Toolbar: Error executing LoadSceneCommand for "${file.name}":`, error); alert(`Error loading scene: ${error.message || 'See console'}`); } } else { logger.error(`Toolbar: Failed to read file "${file.name}" content.`); alert(`Error: Could not read file content for "${file.name}".`); } }; reader.onerror = (e) => { logger.error(`Toolbar: Error reading file "${file.name}":`, e); alert(`Error reading file "${file.name}".`); }; reader.readAsText(file); }
    _handleStartCreateCube(event) { /* ... (Unchanged) ... */ event?.stopPropagation(); if (this.editor?.getMode() !== 'editor') return; logger.log("Toolbar: 'Create Cube' clicked. (Functionality TBD)"); alert("'Create Cube' functionality not yet implemented."); }
    destroy() { /* ... (Unchanged - includes listener removal) ... */ if (this.buttons.play) this.buttons.play.removeEventListener('click', this._handlePlay); if (this.buttons.stop) this.buttons.stop.removeEventListener('click', this._handleStop); if (this.buttons.undo) this.buttons.undo.removeEventListener('click', this._handleUndo); if (this.buttons.redo) this.buttons.redo.removeEventListener('click', this._handleRedo); if (this.buttons.addCubeOld) this.buttons.addCubeOld.removeEventListener('click', this._handleAddCubeOld); if (this.buttons.addSphereOld) this.buttons.addSphereOld.removeEventListener('click', this._handleAddSphereOld); if (this.buttons.startCreateCube) this.buttons.startCreateCube.removeEventListener('click', this._handleStartCreateCube); if (this.buttons.addModel) this.buttons.addModel.removeEventListener('click', this._handleAddModel); if (this.buttons.delete) this.buttons.delete.removeEventListener('click', this._handleDeleteSelected); if (this.buttons.save) this.buttons.save.removeEventListener('click', this._handleSave); if (this.buttons.load) this.buttons.load.removeEventListener('click', this._handleLoadClick); const emitter = this.editor?.eventEmitter; const cmdManager = this.editor?.commandManager; if (emitter) { emitter.off('entitySelected', this._updateButtonsState); emitter.off('gameModeEntered', this._handleModeChange); emitter.off('editorModeEntered', this._handleModeChange); } if (cmdManager) { cmdManager.off('change', this._updateButtonsState); } if (this.fileInput) { this.fileInput.removeEventListener('change', this._handleFileInputChange); this.fileInput = null; } this.buttons = {}; super.destroy(); }
}


// ==================================
// Inspector Class (Unchanged)
// ==================================
class Inspector extends UIComponent {
    /* ... (Implementation unchanged from v1.5.12) ... */
    constructor(editor) { super(editor); this.selectedId = null; this.entityLabel = null; this.fieldsContainer = null; this._isUpdatingInternally = false; this._transformUpdateIgnoreSources = ['physicsSystem', 'spinSystem']; this._onEntitySelected = this._onEntitySelected.bind(this); this._onEntityUpdated = this._onEntityUpdated.bind(this); this._handleModeChange = this._handleModeChange.bind(this); }
    _createElement() { const inspectorDiv = document.createElement('div'); inspectorDiv.className = 'editor-inspector editor-ui-panel'; const header = document.createElement('h3'); header.textContent = 'Inspector'; header.style.cssText = 'margin:0 0 10px 0; padding-bottom:5px; border-bottom:1px solid #555; font-size:1em;'; this.entityLabel = document.createElement('div'); this.entityLabel.className = 'inspector-entity-label'; this.entityLabel.style.cssText = 'margin-bottom:10px; font-style:italic; color:#aaa; min-height: 1.2em;'; this.entityLabel.textContent = 'No entity selected'; this.fieldsContainer = document.createElement('div'); this.fieldsContainer.className = 'inspector-fields'; inspectorDiv.append(header, this.entityLabel, this.fieldsContainer); return inspectorDiv; }
    _setupEventListeners() { if (!this.editor?.eventEmitter) { logger.error("Inspector: Cannot setup listeners."); return; } const emitter = this.editor.eventEmitter; emitter.on('entitySelected', this._onEntitySelected); emitter.on('entityUpdated', this._onEntityUpdated); logger.log("[Inspector] 'entityUpdated' listener enabled with internal flag & source filtering."); emitter.on('gameModeEntered', this._handleModeChange); emitter.on('editorModeEntered', this._handleModeChange); this._onEntitySelected({ id: this.editor.getSelectedEntity() }); this._handleModeChange(); }
    _handleModeChange() { const isEditorMode = this.editor?.getMode() === 'editor'; this.element?.querySelectorAll('input, select, button').forEach(el => { if (el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLButtonElement) { el.disabled = !isEditorMode; } }); }
    _onEntitySelected({ id }) { /* logger.log(`[Inspector] Received selection event: id=${id}`); */ if (this.selectedId !== id) { this.selectedId = id; this._renderFields(); } } // Reduced logging noise
    _onEntityUpdated(eventData) { if (!eventData || eventData.id !== this.selectedId || this._isUpdatingInternally) { return; } const isIgnoredTransformUpdate = eventData.componentType === 'transform' && this._transformUpdateIgnoreSources.includes(eventData.source); if (!isIgnoredTransformUpdate) { this._renderFields(); } }
    _renderFields() { if (!this.fieldsContainer || !this.entityLabel || !this.editor?.entityManager || !this.editor?.componentRegistry) return; const em = this.editor.entityManager; const registry = this.editor.componentRegistry; this.fieldsContainer.innerHTML = ''; if (this.selectedId === null) { this.entityLabel.textContent = 'No entity selected'; return; } if (!em.hasEntity(this.selectedId)) { this.entityLabel.textContent = `Entity ${this.selectedId} (Not Found)`; this.selectedId = null; return; } this.entityLabel.textContent = `Entity ID: ${this.selectedId}`; const components = em.getComponents(this.selectedId); if (components.length === 0) { this.fieldsContainer.innerHTML = '<div style="font-style: italic; color: #aaa;">No components attached.</div>'; return; } components.sort((a, b) => a.constructor.name.localeCompare(b.constructor.name)); components.forEach(componentInstance => { let componentType = null; for (const [name, constructor] of registry.componentTypes.entries()) { if (componentInstance instanceof constructor) { componentType = name; break; } } if (componentType) { this._createComponentSection(componentType, componentInstance); } else { logger.warn(`Inspector: Could not find registered name for component instance on entity ${this.selectedId}:`, componentInstance); this._createGenericComponentSection(componentInstance); } }); this._handleModeChange(); }
    _createComponentSection(type, componentInstance) { if (!this.fieldsContainer) return; const section = document.createElement('details'); section.className = 'component-section'; section.open = true; const summary = document.createElement('summary'); summary.textContent = type; section.append(summary); const contentDiv = document.createElement('div'); const table = document.createElement('table'); let properties; try { properties = componentInstance.serialize ? componentInstance.serialize() : {}; if (typeof componentInstance.serialize !== 'function') { logger.warn(`Inspector: Component type "${type}" missing .serialize().`); properties = Object.fromEntries(Object.entries(componentInstance).filter(([k, v]) => !k.startsWith('_') && typeof v !== 'function')); } } catch (e) { logger.error(`Inspector: Error calling .serialize() on ${type}:`, e); contentDiv.innerHTML = `<span style="color: red;">Error displaying properties.</span>`; section.append(contentDiv); this.fieldsContainer.append(section); return; } const editableKeys = Object.keys(properties).filter(key => !key.startsWith('_') && !['parent', 'children'].includes(key)).sort(); if (editableKeys.length === 0) { contentDiv.innerHTML = `<div style="font-style: italic; color: #aaa; font-size: 0.9em;">No editable properties.</div>`; } else { editableKeys.forEach(key => { const row = this._createPropertyRow(type, componentInstance, key, properties[key]); if (row) table.append(row); }); contentDiv.append(table); } section.append(contentDiv); this.fieldsContainer.append(section); }
    _createGenericComponentSection(componentInstance) { if (!this.fieldsContainer) return; const section = document.createElement('details'); section.className = 'component-section generic-component'; section.open = true; const summary = document.createElement('summary'); summary.textContent = `${componentInstance.constructor.name} (Unregistered?)`; section.append(summary); const contentDiv = document.createElement('div'); contentDiv.style.fontSize = '0.9em'; contentDiv.style.color = '#bbb'; try { contentDiv.textContent = JSON.stringify(componentInstance, null, 2); } catch { contentDiv.textContent = 'Cannot display component state.'; } section.append(contentDiv); this.fieldsContainer.append(section); }
    _createPropertyRow(componentType, componentInstance, key, currentValue) { const row = document.createElement('tr'); const keyCell = document.createElement('td'); keyCell.textContent = key; keyCell.title = key; const valueCell = document.createElement('td'); let inputElement = null; let changeHandler = null; const valueType = typeof currentValue; const isColor = key.toLowerCase() === 'color' && valueType === 'number'; const isArray = Array.isArray(currentValue); const isNumericArray = isArray && currentValue.every(v => typeof v === 'number'); const isVector = isNumericArray && currentValue.length >= 2 && currentValue.length <= 4; const isPhysicsSize = componentType === 'physics' && key === 'colliderSize' && isNumericArray; const dropdownOptions = { 'light.type': ['directional', 'point', 'ambient'], 'camera.type': ['perspective', 'orthographic'], 'renderable.type': ['Cube', 'Sphere', 'Ground', 'Model'], 'physics.bodyType': ['static', 'dynamic', 'kinematicPositionBased'], 'physics.colliderType': ['cuboid', 'ball', 'capsule'], }; const dropdownKey = `${componentType}.${key}`; if (dropdownOptions[dropdownKey]) { inputElement = document.createElement('select'); dropdownOptions[dropdownKey].forEach(opt => { const o = document.createElement('option'); o.value = opt; o.textContent = opt; o.selected = (currentValue === opt); inputElement.appendChild(o); }); inputElement.style.width = '95%'; changeHandler = (e) => e.target.value; } else if (isColor) { inputElement = document.createElement('input'); inputElement.type = 'color'; try { inputElement.value = `#${(currentValue ?? 0).toString(16).padStart(6, '0')}`; } catch { inputElement.value = '#ffffff'; } inputElement.style.cssText = 'width: 60px; height: 24px; padding: 1px 2px;'; changeHandler = (e) => parseInt(e.target.value.substring(1), 16); } else if (valueType === 'number') { inputElement = document.createElement('input'); inputElement.type = 'number'; const lowerKey = key.toLowerCase(); if (lowerKey.includes('angle') || lowerKey.includes('rotation') || lowerKey.includes('fov')) inputElement.step = '1'; else if (lowerKey.includes('intensity') || lowerKey.includes('roughness') || lowerKey.includes('metalness') || lowerKey.includes('damping') || lowerKey.includes('restitution') || lowerKey.includes('friction') || lowerKey.includes('density') || lowerKey === 'near' || lowerKey === 'far') inputElement.step = '0.01'; else inputElement.step = '0.1'; inputElement.value = currentValue; inputElement.style.width = '95%'; changeHandler = (e) => parseFloat(e.target.value) ?? 0; } else if (key === 'assetPath' && componentType === 'renderable') { inputElement = document.createElement('input'); inputElement.type = 'text'; inputElement.value = currentValue ?? ''; inputElement.placeholder = 'e.g., models/car.glb'; inputElement.style.width = '95%'; changeHandler = (e) => e.target.value.trim() || null; } else if (valueType === 'string') { inputElement = document.createElement('input'); inputElement.type = 'text'; inputElement.value = currentValue; inputElement.style.width = '95%'; changeHandler = (e) => e.target.value; } else if (valueType === 'boolean') { inputElement = document.createElement('input'); inputElement.type = 'checkbox'; inputElement.checked = currentValue; inputElement.style.width = 'auto'; changeHandler = (e) => e.target.checked; } else if (isVector || isPhysicsSize) { inputElement = this._createVectorInput(currentValue, componentType, componentInstance, key); } else { const display = document.createElement('span'); try { if (componentType === 'tag' && key === 'tags' && currentValue instanceof Set) { display.textContent = `[${Array.from(currentValue).join(', ')}]`; } else { display.textContent = JSON.stringify(currentValue); } } catch { display.textContent = `[${isArray ? 'Array' : 'Object'}]`; } display.style.cssText = 'color:#aaa; font-size:0.9em; word-break:break-all;'; valueCell.append(display); } if (inputElement && changeHandler && !(inputElement instanceof HTMLElement && inputElement.classList.contains('vector-input-container'))) { let originalValueOnFocus = null; inputElement.onfocus = () => { const liveValue = componentInstance[key]; originalValueOnFocus = (typeof liveValue === 'object' && liveValue !== null && !isColor) ? JSON.parse(JSON.stringify(liveValue)) : liveValue; }; inputElement.onchange = (event) => { if (!this.editor?.commandManager || this.selectedId === null) return; const newValueFromInput = changeHandler(event); const oldValueString = (typeof originalValueOnFocus === 'object' && originalValueOnFocus !== null && !isColor) ? JSON.stringify(originalValueOnFocus) : originalValueOnFocus; const newValueString = (typeof newValueFromInput === 'object' && newValueFromInput !== null && !isColor) ? JSON.stringify(newValueFromInput) : newValueFromInput; if (oldValueString !== newValueString) { const properties = { [key]: { oldValue: originalValueOnFocus, newValue: newValueFromInput } }; const cmd = new UpdateComponentCommand(this.editor, this.selectedId, componentType, properties); this._isUpdatingInternally = true; try { this.editor.commandManager.execute(cmd); } finally { setTimeout(() => { this._isUpdatingInternally = false; }, 0); } } else { const currentCompValue = componentInstance[key]; if (inputElement.type === 'checkbox') inputElement.checked = currentCompValue; else if (inputElement.type === 'color') inputElement.value = `#${(currentValue ?? 0).toString(16).padStart(6, '0')}`; else inputElement.value = currentCompValue ?? ''; } originalValueOnFocus = null; }; valueCell.append(inputElement); } else if (inputElement instanceof HTMLElement && inputElement.classList.contains('vector-input-container')) { valueCell.append(inputElement); } row.append(keyCell, valueCell); return row; }
    _createVectorInput(currentValues, componentType, componentInstance, key) { const container = document.createElement('div'); container.className = 'vector-input-container'; container.style.display = 'flex'; container.style.gap = '4px'; let expectedSize = 3; if (componentType === 'physics' && key === 'colliderSize') { expectedSize = Math.max(1, currentValues.length); } else if (currentValues.length === 2) { expectedSize = 2; } else if (currentValues.length === 4) { expectedSize = 4; } const inputs = []; for (let i = 0; i < expectedSize; i++) { const val = currentValues[i]; const input = document.createElement('input'); input.type = 'number'; const lowerKey = key.toLowerCase(); if (lowerKey.includes('angle') || lowerKey.includes('rotation')) input.step = '1'; else input.step = '0.1'; input.value = (typeof val === 'number' && isFinite(val)) ? val : 0; input.style.flex = '1'; input.style.minWidth = '30px'; inputs.push(input); container.appendChild(input); } let originalValueOnFocus = null; const handleVectorChange = () => { if (!this.editor?.commandManager || this.selectedId === null) return; const newValueFromInput = inputs.map(input => parseFloat(input.value || 0)); if (JSON.stringify(originalValueOnFocus) !== JSON.stringify(newValueFromInput)) { const properties = { [key]: { oldValue: originalValueOnFocus, newValue: newValueFromInput } }; const cmd = new UpdateComponentCommand(this.editor, this.selectedId, componentType, properties); this._isUpdatingInternally = true; try { this.editor.commandManager.execute(cmd); } finally { setTimeout(() => { this._isUpdatingInternally = false; }, 0); } } else { const currentCompValue = componentInstance[key]; if(Array.isArray(currentCompValue)){ inputs.forEach((input, index) => { input.value = (typeof currentCompValue[index] === 'number' && isFinite(currentCompValue[index])) ? currentCompValue[index] : 0; }); } } originalValueOnFocus = null; }; inputs.forEach(input => { input.onfocus = () => { const liveValue = componentInstance[key]; originalValueOnFocus = Array.isArray(liveValue) ? JSON.parse(JSON.stringify(liveValue)) : []; }; input.onchange = handleVectorChange; }); return container; }
    destroy() { /* ... (unchanged) ... */ if (this.editor?.eventEmitter) { const emitter = this.editor.eventEmitter; emitter.off('entitySelected', this._onEntitySelected); emitter.off('entityUpdated', this._onEntityUpdated); emitter.off('gameModeEntered', this._handleModeChange); emitter.off('editorModeEntered', this._handleModeChange); } this.entityLabel = null; this.fieldsContainer = null; super.destroy(); }
}


// ==================================
// MaterialEditor Class (Unchanged)
// ==================================
class MaterialEditor extends UIComponent {
    /* ... (Implementation unchanged) ... */
    constructor(editor) { super(editor); this.selectedEntityId = null; this.selectedThreeObject = null; this.selectedMaterial = null; this.colorInput = null; this.roughnessInput = null; this.metalnessInput = null; this.noMaterialMessage = null; this.propertiesContainer = null; this.changeTracker = { active: false, propertyName: null, oldValue: null }; this._handleEntitySelected = this._handleEntitySelected.bind(this); this._handleColorInput = this._handleColorInput.bind(this); this._handleRoughnessInput = this._handleRoughnessInput.bind(this); this._handleMetalnessInput = this._handleMetalnessInput.bind(this); this._handleColorCommit = this._handleColorCommit.bind(this); this._handleRangeCommit = this._handleRangeCommit.bind(this); }
    _createElement() { const panel = document.createElement('div'); panel.className = 'editor-material-panel editor-ui-panel'; Object.assign(panel.style, { position: 'absolute', top: 'calc(50% + 5px)', left: '170px', width: '260px', height: 'calc(50% - 15px)', overflowY: 'auto', padding: '10px', boxSizing: 'border-box' }); const header = document.createElement('h3'); header.textContent = 'Material'; header.style.cssText = 'margin:0 0 10px 0; padding-bottom:5px; border-bottom:1px solid #555; font-size:1em;'; panel.appendChild(header); this.noMaterialMessage = document.createElement('div'); this.noMaterialMessage.textContent = 'Select mesh with material'; this.noMaterialMessage.style.cssText = 'font-style:italic; color:#aaa; margin-top:10px; font-size: 0.9em;'; panel.appendChild(this.noMaterialMessage); this.propertiesContainer = document.createElement('div'); this.propertiesContainer.style.display = 'none'; panel.appendChild(this.propertiesContainer); this._addMaterialProperties(); return panel; }
    _addMaterialProperties() { this.propertiesContainer.innerHTML = ''; const colorRow = this._createInputRow('Color', 'color'); this.colorInput = colorRow.querySelector('input'); this.propertiesContainer.appendChild(colorRow); const roughnessRow = this._createInputRow('Roughness', 'range'); this.roughnessInput = roughnessRow.querySelector('input'); Object.assign(this.roughnessInput, { min: '0', max: '1', step: '0.01', value: '0.5' }); this.propertiesContainer.appendChild(roughnessRow); const metalnessRow = this._createInputRow('Metalness', 'range'); this.metalnessInput = metalnessRow.querySelector('input'); Object.assign(this.metalnessInput, { min: '0', max: '1', step: '0.01', value: '0.1' }); this.propertiesContainer.appendChild(metalnessRow); }
    _createInputRow(label, inputType) { const row = document.createElement('div'); row.className = 'property-row'; Object.assign(row.style, { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px', fontSize: '0.9em' }); const labelElement = document.createElement('label'); labelElement.textContent = label + ':'; labelElement.style.marginRight = '8px'; row.appendChild(labelElement); const inputElement = document.createElement('input'); inputElement.type = inputType; inputElement.style.boxSizing = 'border-box'; if (inputType === 'range') inputElement.style.width = '80px'; else if (inputType === 'color') { inputElement.style.width = '60px'; inputElement.style.height = '24px'; inputElement.style.padding = '1px 2px'; } else inputElement.style.width = '70px'; row.appendChild(inputElement); return row; }
    _setupEventListeners() { if (!this.editor?.eventEmitter) { logger.error("MaterialEditor: Cannot setup listeners."); return; } this.editor.eventEmitter.on('entitySelected', this._handleEntitySelected); if (this.colorInput) { this.colorInput.addEventListener('input', this._handleColorInput); this.colorInput.addEventListener('change', this._handleColorCommit); this.colorInput.addEventListener('focus', () => this._startTrackingChange('color')); } if (this.roughnessInput) { this.roughnessInput.addEventListener('input', this._handleRoughnessInput); this.roughnessInput.addEventListener('change', this._handleRangeCommit); this.roughnessInput.addEventListener('focus', () => this._startTrackingChange('roughness')); } if (this.metalnessInput) { this.metalnessInput.addEventListener('input', this._handleMetalnessInput); this.metalnessInput.addEventListener('change', this._handleRangeCommit); this.metalnessInput.addEventListener('focus', () => this._startTrackingChange('metalness')); } this._handleEntitySelected({ id: this.editor.getSelectedEntity() }); }
    _handleEntitySelected({ id }) { if (!this.element || !this.editor) return; this.selectedEntityId = id; this.selectedThreeObject = null; this.selectedMaterial = null; this.changeTracker.active = false; if (id !== null) { const rendererSystem = this.editor.getSystem('renderer'); if (rendererSystem?.entityObjects?.get) { const entry = rendererSystem.entityObjects.get(id); if (entry && (entry.type === 'mesh' || entry.type === 'model') && entry.threeObject?.material && !Array.isArray(entry.threeObject.material)) { this.selectedThreeObject = entry.threeObject; if (this.selectedThreeObject.material.isMeshStandardMaterial) { this.selectedMaterial = this.selectedThreeObject.material; } else { logger.log(`MaterialEditor: Selected object (${id}) material is not MeshStandardMaterial.`); } } } else { logger.warn("MaterialEditor: Renderer system or entityObjects map missing."); } } this._updateMaterialUI(); }
    _updateMaterialUI() { if (!this.propertiesContainer || !this.noMaterialMessage) return; const hasMaterial = this.selectedMaterial?.isMeshStandardMaterial; this.propertiesContainer.style.display = hasMaterial ? 'block' : 'none'; this.noMaterialMessage.style.display = hasMaterial ? 'none' : 'block'; if (!hasMaterial) { this.noMaterialMessage.textContent = this.selectedEntityId !== null ? 'Selected object has no editable material (requires MeshStandardMaterial).' : 'Select mesh with material'; return; } try { if (this.colorInput && this.selectedMaterial.color) { const hex = `#${this.selectedMaterial.color.getHexString()}`; if (this.colorInput.value !== hex) this.colorInput.value = hex; } if (this.roughnessInput) { this.roughnessInput.disabled = false; const v = this.selectedMaterial.roughness.toString(); if(this.roughnessInput.value !== v) this.roughnessInput.value = v; } if (this.metalnessInput) { this.metalnessInput.disabled = false; const v = this.selectedMaterial.metalness.toString(); if(this.metalnessInput.value !== v) this.metalnessInput.value = v; } } catch (error) { logger.error("MaterialEditor: Error updating UI fields:", error); this.propertiesContainer.style.display = 'none'; this.noMaterialMessage.textContent = 'Error accessing material properties.'; this.noMaterialMessage.style.display = 'block'; } }
    _handleColorInput(e) { if (this.selectedMaterial?.color) { try { this.selectedMaterial.color.set(e.target.value); } catch(err) { logger.warn("Error setting color preview:", err); } } }
    _handleRoughnessInput(e) { if (this.selectedMaterial?.roughness !== undefined) { this.selectedMaterial.roughness = parseFloat(e.target.value); } }
    _handleMetalnessInput(e) { if (this.selectedMaterial?.metalness !== undefined) { this.selectedMaterial.metalness = parseFloat(e.target.value); } }
    _startTrackingChange(propertyName) { if (!this.selectedEntityId || !this.editor) return; const component = this.editor.getComponent(this.selectedEntityId, 'renderable'); if (component && component[propertyName] !== undefined) { this.changeTracker.active = true; this.changeTracker.propertyName = propertyName; const oldValue = component[propertyName]; this.changeTracker.oldValue = (typeof oldValue === 'object' && oldValue !== null) ? JSON.parse(JSON.stringify(oldValue)) : oldValue; } else { logger.warn(`MaterialEditor: Cannot track change for non-existent property "${propertyName}" on RenderableComponent.`); this.changeTracker.active = false; } }
    _handleColorCommit(e) { this._commitChange(parseInt(e.target.value.substring(1), 16)); }
    _handleRangeCommit(e) { this._commitChange(parseFloat(e.target.value)); }
    _commitChange(newValue) { if (!this.changeTracker.active || this.changeTracker.propertyName === null || !this.selectedEntityId || !this.editor?.getCommandManager()) { logger.warn(`MaterialEditor: _commitChange aborted. State:`, { tracker: this.changeTracker, entityId: this.selectedEntityId }); this.changeTracker.active = false; return; } const propertyName = this.changeTracker.propertyName; const oldValue = this.changeTracker.oldValue; const currentEntityId = this.selectedEntityId; this.changeTracker.active = false; const valueChanged = JSON.stringify(oldValue) !== JSON.stringify(newValue); if (valueChanged) { const commandProperties = { [propertyName]: { oldValue: oldValue, newValue: newValue } }; logger.log(`MaterialEditor: Creating UpdateComponentCommand for Entity: ${currentEntityId}, Component: renderable, Properties:`, commandProperties); try { const command = new UpdateComponentCommand(this.editor, currentEntityId, 'renderable', commandProperties); this.editor.getCommandManager().execute(command); logger.log(`MaterialEditor: Executed UpdateComponentCommand for ${propertyName}.`); } catch (commandError) { logger.error("MaterialEditor: Error executing UpdateComponentCommand:", commandError); this._updateMaterialUI(); } } else { logger.log(`MaterialEditor: Value for ${propertyName} did not change. Reverting live preview.`); this._updateMaterialUI(); } }
    destroy() { if (this.editor?.eventEmitter) { this.editor.eventEmitter.off('entitySelected', this._handleEntitySelected); } if (this.colorInput) { this.colorInput.removeEventListener('input', this._handleColorInput); this.colorInput.removeEventListener('change', this._handleColorCommit); } if (this.roughnessInput) { this.roughnessInput.removeEventListener('input', this._handleRoughnessInput); this.roughnessInput.removeEventListener('change', this._handleRangeCommit); } if (this.metalnessInput) { this.metalnessInput.removeEventListener('input', this._handleMetalnessInput); this.metalnessInput.removeEventListener('change', this._handleRangeCommit); } this.colorInput = null; this.roughnessInput = null; this.metalnessInput = null; this.propertiesContainer = null; this.noMaterialMessage = null; this.selectedMaterial = null; this.selectedThreeObject = null; super.destroy(); }
}


// ==================================
// StatusBar Class (Unchanged)
// ==================================
class StatusBar extends UIComponent {
    /* ... (Implementation unchanged) ... */
    constructor(editor) { super(editor); this.textEl = null; this._loadingAssets = new Set(); this._lastStatusMessage = 'Initializing...'; this._clearLoadingTimeout = null; this._onSelectionChanged = this._onSelectionChanged.bind(this); this._handleAssetLoadStart = this._handleAssetLoadStart.bind(this); this._handleAssetLoadProgress = this._handleAssetLoadProgress.bind(this); this._handleAssetLoadEnd = this._handleAssetLoadEnd.bind(this); this._updateStatusText = this._updateStatusText.bind(this); this._handleModeChange = this._handleModeChange.bind(this); }
    _createElement() { const div = document.createElement('div'); div.className = 'editor-status-bar editor-ui-panel'; Object.assign(div.style, { position: 'absolute', bottom: '10px', left: '10px', right: '10px', height: '25px', padding: '5px 10px', fontSize: '0.9em', opacity: '0.9', zIndex: '210', lineHeight: '25px', boxSizing: 'border-box' }); this.textEl = div; this.textEl.textContent = this._lastStatusMessage; this.textEl.style.whiteSpace = 'nowrap'; this.textEl.style.overflow = 'hidden'; this.textEl.style.textOverflow = 'ellipsis'; return div; }
    _setupEventListeners() { if (!this.editor?.eventEmitter) { logger.error("StatusBar: Cannot setup listeners."); return; } const emitter = this.editor.eventEmitter; emitter.on('entitySelected', this._onSelectionChanged); emitter.on('assetLoadStart', this._handleAssetLoadStart); emitter.on('assetLoadProgress', this._handleAssetLoadProgress); emitter.on('assetLoadComplete', this._handleAssetLoadEnd); emitter.on('assetLoadError', this._handleAssetLoadEnd); emitter.on('gameModeEntered', this._handleModeChange); emitter.on('editorModeEntered', this._handleModeChange); this._onSelectionChanged({ id: this.editor.getSelectedEntity() }); this._handleModeChange(); }
    _handleModeChange() { this._updateStatusText(); }
    _updateStatusText() { if (!this.textEl) return; if (this._clearLoadingTimeout) { clearTimeout(this._clearLoadingTimeout); this._clearLoadingTimeout = null; } if (this._loadingAssets.size > 0) { const firstAsset = this._loadingAssets.values().next().value; const shortPath = typeof firstAsset === 'string' ? firstAsset.split(/[\\/]/).pop() : 'asset'; this.textEl.textContent = `Loading ${this._loadingAssets.size} asset(s)... (${shortPath})`; this.textEl.title = `Loading: ${firstAsset}`; this.textEl.style.color = '#ffffaa'; } else { this.textEl.textContent = this._lastStatusMessage; this.textEl.title = this._lastStatusMessage; this.textEl.style.color = ''; } }
    _setLastStatusMessage(message) { this._lastStatusMessage = message; if (this._loadingAssets.size === 0) { this._updateStatusText(); } }
    _onSelectionChanged({ id }) { if (!this.editor) return; let message = ''; if (id === null) { message = 'No entity selected'; } else if (this.editor.hasEntity(id)) { const rend = this.editor.getComponent(id, 'renderable'); const light = this.editor.getComponent(id, 'light'); const cam = this.editor.getComponent(id, 'camera'); let typeName = 'Entity'; if (rend) typeName = rend.type || 'Renderable'; else if (light) typeName = light.type ? `${light.type} Light` : 'Light'; else if (cam) typeName = cam.type ? `${cam.type} Camera` : 'Camera'; message = `Selected: ${typeName} ${id}`; } else { message = `Selected: Entity ${id} (Not Found)`; } this._setLastStatusMessage(message); }
    _handleAssetLoadStart({ path }) { if (path) { this._loadingAssets.add(path); this._updateStatusText(); } }
    _handleAssetLoadProgress({ path, progress }) { if (this.textEl && this._loadingAssets.size > 0) { const firstAsset = this._loadingAssets.values().next().value; if(path === firstAsset) { const shortPath = path.split(/[\\/]/).pop(); const percent = (progress * 100).toFixed(0); this.textEl.textContent = `Loading ${this._loadingAssets.size}: ${shortPath} (${percent}%)`; this.textEl.title = `Loading: ${path} (${percent}%)`; } } }
    _handleAssetLoadEnd({ path, error }) { if (path) { const removed = this._loadingAssets.delete(path); if (removed) { if (error) { if(this.textEl) { const shortPath = path.split(/[\\/]/).pop(); const errorMsg = `Error loading ${shortPath}: ${error || 'Unknown error'}`; this.textEl.textContent = errorMsg; this.textEl.title = errorMsg; this.textEl.style.color = '#ffaaaa'; if (this._clearLoadingTimeout) clearTimeout(this._clearLoadingTimeout); const timeoutMs = engineConfig.statusBar?.clearLoadingTimeoutMs ?? 3000; this._clearLoadingTimeout = setTimeout(this._updateStatusText, timeoutMs); } } else { this._updateStatusText(); } } } }
    destroy() { if (this.editor?.eventEmitter) { const emitter = this.editor.eventEmitter; emitter.off('entitySelected', this._onSelectionChanged); emitter.off('assetLoadStart', this._handleAssetLoadStart); emitter.off('assetLoadProgress', this._handleAssetLoadProgress); emitter.off('assetLoadComplete', this._handleAssetLoadEnd); emitter.off('assetLoadError', this._handleAssetLoadEnd); emitter.off('gameModeEntered', this._handleModeChange); emitter.off('editorModeEntered', this._handleModeChange); } if (this._clearLoadingTimeout) clearTimeout(this._clearLoadingTimeout); this.textEl = null; this._loadingAssets.clear(); super.destroy(); }
}